<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Butterfly Demo">
    <title>Butterfly Demo</title>
    
     <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        .d-flex{
            display: flex;
        }
        .justify-content-center{
            justify-content: center;
        }
        .align-items-center{
            align-items: center;
        }
        .flex-column{
            flex-direction: column;
        }
        .flex-row{
            flex-direction: row;
        }
        .flex-wrap{
            flex-wrap: wrap;
        }
        .flex-nowrap{
            flex-wrap: nowrap;
        }

        .flex-grow-1{
            flex-grow: 1;
        }
        .flex-grow-2{
            flex-grow: 2;
        }
        .flex-grow-3{   
            flex-grow: 3;
        }
        .flex-grow-4{
            flex-grow: 4;
        }
        .flex-grow-5{
            flex-grow: 5;
        }
        .mx-auto{
            margin-left: auto;
            margin-right: auto;
        }
        .mx-2{
            margin-left: 2rem;
            margin-right: 2rem;
        }
        .mx-4{
            margin-left: 4rem;
            margin-right: 4rem;
        }
        .mx-6{
            margin-left: 6rem;
            margin-right: 6rem;
        }
        .px-2{
            padding-left: 2rem;
            padding-right: 2rem;
        }
        .px-4{
            padding-left: 4rem;
            padding-right: 4rem;
        }
        .px-6{
            padding-left: 6rem;
            padding-right: 6rem;
        }
     </style>
</head>

<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="info">

            <div id="loading">Loading model...</div>

        </div>
    </div>
   <!-- Use ES6 modules - this is the modern way -->
   <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.166.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.166.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script> 

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });

        // Set renderer size and add to container
        const pixelRatio = window.devicePixelRatio || 1;

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(pixelRatio, 3)); // Cap at 2x for performanceat 2x for performance
        renderer.setClearColor(0x87CEEB); // Sky blue background

        // Enable shadows for better lighting
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Position camera
        camera.position.set(0, 0, 6);

        // Add camera controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.enableRotate = true;
        controls.minDistance = 1;
        controls.maxDistance = 20;
        controls.maxPolarAngle = Math.PI;

        // Sky and model objects
        let sky, modelInstances = [];
        let originalModel = null; // Store the original model for cloning

        // Create sky background
        function createSky() {
            // Create a large sphere for the sky
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            
            // Create gradient sky material
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0xc7dff0) },
                    bottomColor: { value: new THREE.Color(0xecf7ff) },
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }

        // Create multiple model instances
        function createModelInstances() {
            if (!originalModel) return;

            // Clear existing instances
            modelInstances.forEach(instance => scene.remove(instance));
            modelInstances = [];

            // Create multiple instances of the model
            for (let i = 0; i < 500; i++) {
                const instance = originalModel.clone();
                
        // Generate random position
            const radius = 30 + Math.random() * 150; // Start further away
            const theta = Math.random() * Math.PI * 10;
            const phi = Math.random() * Math.PI * 0.5;

                instance.position.set(
                    radius * Math.cos(theta),
                    Math.random() * 150 - 10,
                    radius * Math.sin(phi) * Math.sin(theta)
                );
                
                // Random scale for variety
                const scale = 0.5 + Math.random() * 1;
                instance.scale.setScalar(scale);
                
                // Random rotation
                instance.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                // Ensure materials are properly set
                instance.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        
                        if (child.material) {
                            child.material.needsUpdate = true;
                        }
                    }
                });
                
                modelInstances.push(instance);
                scene.add(instance);
            }
        }

        // Animate model instances
        function animateModelInstances() {
            modelInstances.forEach((instance, index) => {
                // Slow rotation
                instance.rotation.y += 0.002 * (index % 3 + 1);
                instance.rotation.x += 0.001 * (index % 2 + 1);
                
                // Gentle floating motion
                instance.position.y += Math.sin(Date.now() * 0.001 + index) * 0.005;
            });
        }

        // Create sky
        createSky();

        // Lighting objects
        let lights = {};

        // Better balanced lighting setup
        function setupLighting() {
            // Moderate ambient light - just for base illumination
            lights.ambient = new THREE.AmbientLight(0xffffff, 100);
            scene.add(lights.ambient);

            // Hemisphere light - subtle color variation
            lights.hemisphere = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 1000);
            lights.hemisphere.position.set(0, 3, 3);

            scene.add(lights.hemisphere);

            // Main directional light - primary illumination
            lights.directional = new THREE.DirectionalLight(0xffffff, 8);
            lights.directional.position.set(0, 3, 3);
            lights.directional.castShadow = true;
            scene.add(lights.directional);

            // Fill directional light - from opposite side
            lights.directional2 = new THREE.DirectionalLight(0xffffff, 15);
            lights.directional2.position.set(0, 3, -3);
            lights.directional2.castShadow = false;
            scene.add(lights.directional2);

            // Third directional light - from above
            lights.directional3 = new THREE.DirectionalLight(0xffffff, 8);
            lights.directional3.position.set(10, 5, 0);
            lights.directional3.castShadow = false;
            scene.add(lights.directional3);

            // Strong point light - much more powerful
            lights.point = new THREE.PointLight(0xffffff, 1.0, 50);
            lights.point.position.set(0, 0, 3);
            lights.point.castShadow = false;
            scene.add(lights.point);

            // Additional point lights for even coverage
            lights.point2 = new THREE.PointLight(0xffff00, 10, 300);
            lights.point2.position.set(4, 10, 0);
            lights.point2.castShadow = false;
            scene.add(lights.point2);

            lights.point3 = new THREE.PointLight(0xffffff, 0.6, 130);
            lights.point3.position.set(-4, 0, 0);
            lights.point3.castShadow = false;
            scene.add(lights.point3);

                        // Add additional point lights around the scene
            lights.point4 = new THREE.PointLight(0xffffff, 1, 100);
            lights.point4.position.set(0, 0, -10);
            scene.add(lights.point4);

            lights.point5 = new THREE.PointLight(0xffffff, 1, 100);
            lights.point5.position.set(10, 0, 0);
            scene.add(lights.point5);

            lights.point6 = new THREE.PointLight(0xffffff, 1, 200);
            lights.point6.position.set(-10, 0, 0);
            scene.add(lights.point6);
        }

        // Setup the lighting
        setupLighting();

        // GUI setup
        function setupGUI() {
            const gui = new dat.GUI();
            
            // Sky folder
            const skyFolder = gui.addFolder('Sky & Environment');
            const skySettings = {
                skyTopColor: 0x87CEEB,
                skyBottomColor: 0xE0F6FF,
                modelCount: 15,
                modelScale: 1.0,
                animationSpeed: 1.0
            };
            
            skyFolder.addColor(skySettings, 'skyTopColor').name('Sky Top Color').onChange((value) => {
                sky.material.uniforms.topColor.value.setHex(value);
            });
            
            skyFolder.addColor(skySettings, 'skyBottomColor').name('Sky Bottom Color').onChange((value) => {
                sky.material.uniforms.bottomColor.value.setHex(value);
            });
            
            skyFolder.add(skySettings, 'modelCount', 5, 50).name('Model Count').onChange((value) => {
                // Update model count
                createModelInstances();
            });
            
            skyFolder.add(skySettings, 'modelScale', 0.1, 3).name('Model Scale').onChange((value) => {
                modelInstances.forEach(instance => {
                    instance.scale.setScalar(value);
                });
            });
            
            skyFolder.add(skySettings, 'animationSpeed', 0, 3).name('Animation Speed').onChange((value) => {
                window.animationSpeed = value;
            });
            
            // Lighting folder
            const lightingFolder = gui.addFolder('Lighting Controls');
            
            // Ambient light controls
            const ambientFolder = lightingFolder.addFolder('Ambient Light');
            ambientFolder.addColor(lights.ambient, 'color');
            ambientFolder.add(lights.ambient, 'intensity', 0, 1).name('Intensity');
            
            // Hemisphere light controls
            const hemisphereFolder = lightingFolder.addFolder('Hemisphere Light');
            hemisphereFolder.addColor(lights.hemisphere, 'color').name('Sky Color');
            hemisphereFolder.addColor(lights.hemisphere, 'groundColor').name('Ground Color');
            hemisphereFolder.add(lights.hemisphere, 'intensity', 0, 1).name('Intensity');
            
            // Directional lights
            const directionalFolder = lightingFolder.addFolder('Directional Lights');
            directionalFolder.add(lights.directional, 'intensity', 0, 20).name('Main Light');
            directionalFolder.add(lights.directional2, 'intensity', 0, 20).name('Fill Light');
            directionalFolder.add(lights.directional3, 'intensity', 0, 20).name('Top Light');
            directionalFolder.add(lights.directional.position, 'x', -100, 100).name('x');
            directionalFolder.add(lights.directional.position, 'y', -100, 100).name('y');
            directionalFolder.add(lights.directional.position, 'z', -100, 100).name('z');
            directionalFolder.add(lights.directional2, 'intensity', 0, 20).name('Fill Light');
            directionalFolder.add(lights.directional2.position, 'x', -100, 100).name('x');
            directionalFolder.add(lights.directional2.position, 'y', -100, 100).name('y');
            directionalFolder.add(lights.directional2.position, 'z', -100, 100).name('z');
            directionalFolder.add(lights.directional3, 'intensity', 0, 20).name('Top Light');
            directionalFolder.add(lights.directional3.position, 'x', -100, 100).name('x');
            directionalFolder.add(lights.directional3.position, 'y', -100, 100).name('y');
            directionalFolder.add(lights.directional3.position, 'z', -100, 100).name('z');
            
            // Point lights
            const pointFolder = lightingFolder.addFolder('Point Lights');
            pointFolder.add(lights.point, 'intensity', 0, 2).name('Center Point');
            pointFolder.add(lights.point2, 'intensity', 0, 2).name('Right Point');
            pointFolder.add(lights.point3, 'intensity', 0, 2).name('Left Point');
            
            // Overall lighting controls
            const overallFolder = lightingFolder.addFolder('Overall Settings');
            const lightingSettings = {
                overallIntensity: 1.0,
                ambientOnly: false,
                directionalOnly: false,
                pointOnly: false
            };
            
            overallFolder.add(lightingSettings, 'overallIntensity', 0, 2).name('Overall Intensity').onChange((value) => {
                lights.ambient.intensity = 0.4 * value;
                lights.hemisphere.intensity = 0.6 * value;
                lights.directional.intensity = 0.8 * value;
                lights.directional2.intensity = 0.6 * value;
                lights.directional3.intensity = 0.4 * value;
                lights.point.intensity = 1.0 * value;
                lights.point2.intensity = 0.6 * value;
                lights.point3.intensity = 0.6 * value;
            });
            
            overallFolder.add(lightingSettings, 'ambientOnly').name('Ambient Only').onChange((value) => {
                lights.ambient.visible = value;
                lights.hemisphere.visible = value;
                lights.directional.visible = !value;
                lights.directional2.visible = !value;
                lights.directional3.visible = !value;
                lights.point.visible = !value;
                lights.point2.visible = !value;
                lights.point3.visible = !value;
            });
            
            overallFolder.add(lightingSettings, 'directionalOnly').name('Directional Only').onChange((value) => {
                lights.ambient.visible = !value;
                lights.hemisphere.visible = !value;
                lights.directional.visible = value;
                lights.directional2.visible = value;
                lights.directional3.visible = value;
                lights.point.visible = !value;
                lights.point2.visible = !value;
                lights.point3.visible = !value;
            });
            
            overallFolder.add(lightingSettings, 'pointOnly').name('Point Only').onChange((value) => {
                lights.ambient.visible = !value;
                lights.hemisphere.visible = !value;
                lights.directional.visible = !value;
                lights.directional2.visible = !value;
                lights.directional3.visible = !value;
                lights.point.visible = value;
                lights.point2.visible = value;
                lights.point3.visible = value;
            });
            
            // Renderer controls
            const rendererFolder = gui.addFolder('Renderer');
            const backgroundColor = { color: 0x87CEEB };
            rendererFolder.addColor(backgroundColor, 'color').name('Background Color').onChange((value) => {
                renderer.setClearColor(value);
            });
            
            // Camera controls
            const cameraFolder = gui.addFolder('Camera');
            cameraFolder.add(camera.position, 'x', -20, 20).name('Position X');
            cameraFolder.add(camera.position, 'y', -20, 20).name('Position Y');
            cameraFolder.add(camera.position, 'z', -20, 20).name('Position Z');
            
            // Open folders
            skyFolder.open();
            lightingFolder.open();
            directionalFolder.open();
        }

        // Setup GUI
        setupGUI();

        // Load GLB model
        const loader = new GLTFLoader();
        const loadingElement = document.getElementById('loading');

        let model = null;
        loader.load(
            'glb/textured_mesh.glb',
            function (gltf) {
                // Store the original model
                originalModel = gltf.scene.clone();
   

                // Add the main model to the center
                model = gltf.scene;
                scene.add(model);
                loadingElement.textContent = 'Model loaded!';
                
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);
                model.scale.setScalar(3); // Keep your preferred scale
                
                // Ensure materials are properly lit
                model.traverse((child) => {

                    if (child.isMesh && child.material) {
                        child.material.emissive = new THREE.Color(0x111111); // Slight glow
                        child.material.emissiveIntensity = 1;
                    }
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        
                        if (child.material) {
                            child.material.needsUpdate = true;
                        }
                    }
                });
                
                // Create multiple instances around the main model
                createModelInstances();
                
                controls.target.copy(center);
                controls.update();
                
                console.log('GLB model loaded:', gltf);
            },
            function (progress) {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                loadingElement.textContent = `Loading model... ${percent}%`;
            },
            function (error) {
                console.error('Error loading GLB model:', error);
                loadingElement.textContent = 'Error loading model';
            }
        );

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (model) {
                model.rotation.y += 0.001; // Adjust speed as needed
                // You can also add rotation on other axes:
                // mainModel.rotation.x += 0.002;
                // mainModel.rotation.z += 0.001;
            }

            // Animate model instances
            animateModelInstances();
            
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>

</body>
</html>