<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Three.js WebGL Demo">
    <title>Three.js 3D Model Viewer</title>
    
     <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        .d-flex{
            display: flex;
        }
        .justify-content-center{
            justify-content: center;
        }
        .align-items-center{
            align-items: center;
        }
        .flex-column{
            flex-direction: column;
        }
        .flex-row{
            flex-direction: row;
        }
        .flex-wrap{
            flex-wrap: wrap;
        }
        .flex-nowrap{
            flex-wrap: nowrap;
        }

        .flex-grow-1{
            flex-grow: 1;
        }
        .flex-grow-2{
            flex-grow: 2;
        }
        .flex-grow-3{   
            flex-grow: 3;
        }
        .flex-grow-4{
            flex-grow: 4;
        }
        .flex-grow-5{
            flex-grow: 5;
        }
        .mx-auto{
            margin-left: auto;
            margin-right: auto;
        }
        .mx-2{
            margin-left: 2rem;
            margin-right: 2rem;
        }
        .mx-4{
            margin-left: 4rem;
            margin-right: 4rem;
        }
        .mx-6{
            margin-left: 6rem;
            margin-right: 6rem;
        }
        .px-2{
            padding-left: 2rem;
            padding-right: 2rem;
        }
        .px-4{
            padding-left: 4rem;
            padding-right: 4rem;
        }
        .px-6{
            padding-left: 6rem;
            padding-right: 6rem;
        }
     </style>
</head>

<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="info">
            <h1>Three.js Demo</h1>
            <p>WebGL 3D Graphics</p>
            <div id="loading">Loading model...</div>

        </div>
    </div>
   <!-- Use ES6 modules - this is the modern way -->
   <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.166.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.166.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });

        // Set renderer size and add to container
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB); // Sky blue background

        // Enable shadows for better lighting
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Position camera
        camera.position.set(0, 0, 5);

        // Add camera controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.enableRotate = true;
        controls.minDistance = 1;
        controls.maxDistance = 20;
        controls.maxPolarAngle = Math.PI;

        // Sky and cloud objects
        let sky, clouds = [];

        // Create sky background
        function createSky() {
            // Create a large sphere for the sky
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            
            // Create gradient sky material
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0xFFFFFF) },
                    bottomColor: { value: new THREE.Color(0xE0F6FF) },
                    offset: { value: 33 },
                    exponent: { value: 1.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }

        // Create cloud system
        function createClouds() {
            const cloudGeometry = new THREE.SphereGeometry(1, 8, 8);
            const cloudMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });

            // Create multiple clouds at different positions
            for (let i = 0; i < 20; i++) {
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                
                // Random position in a large sphere around the scene
                const radius = 50 + Math.random() * 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                cloud.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.cos(phi) + 20, // Keep clouds above ground
                    radius * Math.sin(phi) * Math.sin(theta)
                );
                
                // Random scale for variety
                const scale = 5 + Math.random() * 15;
                cloud.scale.set(scale, scale * 0.6, scale);
                
                // Random rotation
                cloud.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                clouds.push(cloud);
                scene.add(cloud);
            }
        }

        // Animate clouds
        function animateClouds() {
            clouds.forEach((cloud, index) => {
                // Slow rotation
                cloud.rotation.y += 0.001 * (index % 3 + 1);
                cloud.rotation.x += 0.0005 * (index % 2 + 1);
                
                // Gentle floating motion
                cloud.position.y += Math.sin(Date.now() * 0.001 + index) * 0.01;
            });
        }

        // Create sky and clouds
        createSky();
        createClouds();

        // Lighting objects
        let lights = {};

        // Better balanced lighting setup
        function setupLighting() {
            // Moderate ambient light - just for base illumination
            lights.ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(lights.ambient);

            // Hemisphere light - subtle color variation
            lights.hemisphere = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.6);
            scene.add(lights.hemisphere);

            // Main directional light - primary illumination
            lights.directional = new THREE.DirectionalLight(0xffffff, 10);
            lights.directional.position.set(3, 3, 3);
            lights.directional.castShadow = false;
            scene.add(lights.directional);

            // Fill directional light - from opposite side
            lights.directional2 = new THREE.DirectionalLight(0xffffff, 10);
            lights.directional2.position.set(-3, 2, -3);
            lights.directional2.castShadow = false;
            scene.add(lights.directional2);

            // Third directional light - from above
            lights.directional3 = new THREE.DirectionalLight(0xffffff, 20);
            lights.directional3.position.set(0, 5, 0);
            lights.directional3.castShadow = false;
            scene.add(lights.directional3);

            // Strong point light - much more powerful
            lights.point = new THREE.PointLight(0xffffff, 1.0, 50);
            lights.point.position.set(0, 0, 3);
            lights.point.castShadow = false;
            scene.add(lights.point);

            // Additional point lights for even coverage
            lights.point2 = new THREE.PointLight(0xffffff, 0.6, 30);
            lights.point2.position.set(4, 0, 0);
            lights.point2.castShadow = false;
            scene.add(lights.point2);

            lights.point3 = new THREE.PointLight(0xffffff, 0.6, 30);
            lights.point3.position.set(-4, 0, 0);
            lights.point3.castShadow = false;
            scene.add(lights.point3);
        }

        // Setup the lighting
        setupLighting();

        // GUI setup
        function setupGUI() {
            const gui = new dat.GUI();
            
            // Sky folder
            const skyFolder = gui.addFolder('Sky & Clouds');
            const skySettings = {
                skyTopColor: 0xFFFFFF,
                skyBottomColor: 0XEEF5FF,
                cloudOpacity: 0.1,
                cloudSpeed: 1.0,
                cloudCount: 100
            };
            
            skyFolder.addColor(skySettings, 'skyTopColor').name('Sky Top Color').onChange((value) => {
                sky.material.uniforms.topColor.value.setHex(value);
            });
            
            skyFolder.addColor(skySettings, 'skyBottomColor').name('Sky Bottom Color').onChange((value) => {
                sky.material.uniforms.bottomColor.value.setHex(value);
            });
            
            skyFolder.add(skySettings, 'cloudOpacity', 0, 1).name('Cloud Opacity').onChange((value) => {
                clouds.forEach(cloud => {
                    cloud.material.opacity = value;
                });
            });
            
            skyFolder.add(skySettings, 'cloudSpeed', 0, 3).name('Cloud Speed').onChange((value) => {
                // Store speed for animation loop
                window.cloudSpeed = value;
            });
            
            skyFolder.add(skySettings, 'cloudCount', 5, 50).name('Cloud Count').onChange((value) => {
                // Remove existing clouds
                clouds.forEach(cloud => scene.remove(cloud));
                clouds = [];
                
                // Create new clouds
                createClouds();
            });
            
            // Lighting folder
            const lightingFolder = gui.addFolder('Lighting Controls');
            
            // Ambient light controls
            const ambientFolder = lightingFolder.addFolder('Ambient Light');
            ambientFolder.addColor(lights.ambient, 'color');
            ambientFolder.add(lights.ambient, 'intensity', 0, 1).name('Intensity');
            
            // Hemisphere light controls
            const hemisphereFolder = lightingFolder.addFolder('Hemisphere Light');
            hemisphereFolder.addColor(lights.hemisphere, 'color').name('Sky Color');
            hemisphereFolder.addColor(lights.hemisphere, 'groundColor').name('Ground Color');
            hemisphereFolder.add(lights.hemisphere, 'intensity', 0, 1).name('Intensity');
            
            // Directional lights
            const directionalFolder = lightingFolder.addFolder('Directional Lights');
            directionalFolder.add(lights.directional, 'intensity', 0, 20).name('Main Light');
            directionalFolder.add(lights.directional2, 'intensity', 0, 20).name('Fill Light');
            directionalFolder.add(lights.directional3, 'intensity', 0, 20).name('Top Light');
            
            // Point lights
            const pointFolder = lightingFolder.addFolder('Point Lights');
            pointFolder.add(lights.point, 'intensity', 0, 2).name('Center Point');
            pointFolder.add(lights.point2, 'intensity', 0, 2).name('Right Point');
            pointFolder.add(lights.point3, 'intensity', 0, 2).name('Left Point');
            
            // Overall lighting controls
            const overallFolder = lightingFolder.addFolder('Overall Settings');
            const lightingSettings = {
                overallIntensity: 1.0,
                ambientOnly: false,
                directionalOnly: false,
                pointOnly: false
            };
            
            overallFolder.add(lightingSettings, 'overallIntensity', 0, 2).name('Overall Intensity').onChange((value) => {
                lights.ambient.intensity = 0.4 * value;
                lights.hemisphere.intensity = 0.6 * value;
                lights.directional.intensity = 0.8 * value;
                lights.directional2.intensity = 0.6 * value;
                lights.directional3.intensity = 0.4 * value;
                lights.point.intensity = 1.0 * value;
                lights.point2.intensity = 0.6 * value;
                lights.point3.intensity = 0.6 * value;
            });
            
            overallFolder.add(lightingSettings, 'ambientOnly').name('Ambient Only').onChange((value) => {
                lights.ambient.visible = value;
                lights.hemisphere.visible = value;
                lights.directional.visible = !value;
                lights.directional2.visible = !value;
                lights.directional3.visible = !value;
                lights.point.visible = !value;
                lights.point2.visible = !value;
                lights.point3.visible = !value;
            });
            
            overallFolder.add(lightingSettings, 'directionalOnly').name('Directional Only').onChange((value) => {
                lights.ambient.visible = !value;
                lights.hemisphere.visible = !value;
                lights.directional.visible = value;
                lights.directional2.visible = value;
                lights.directional3.visible = value;
                lights.point.visible = !value;
                lights.point2.visible = !value;
                lights.point3.visible = !value;
            });
            
            overallFolder.add(lightingSettings, 'pointOnly').name('Point Only').onChange((value) => {
                lights.ambient.visible = !value;
                lights.hemisphere.visible = !value;
                lights.directional.visible = !value;
                lights.directional2.visible = !value;
                lights.directional3.visible = !value;
                lights.point.visible = value;
                lights.point2.visible = value;
                lights.point3.visible = value;
            });
            
            // Renderer controls
            const rendererFolder = gui.addFolder('Renderer');
            const backgroundColor = { color: 0x87CEEB };
            rendererFolder.addColor(backgroundColor, 'color').name('Background Color').onChange((value) => {
                renderer.setClearColor(value);
            });
            
            // Camera controls
            const cameraFolder = gui.addFolder('Camera');
            cameraFolder.add(camera.position, 'x', -20, 20).name('Position X');
            cameraFolder.add(camera.position, 'y', -20, 20).name('Position Y');
            cameraFolder.add(camera.position, 'z', -20, 20).name('Position Z');
            
            // Open folders
            skyFolder.open();
            lightingFolder.open();
            directionalFolder.open();
        }

        // Setup GUI
        setupGUI();

        // Load GLB model
        const loader = new GLTFLoader();
        const loadingElement = document.getElementById('loading');

        loader.load(
            'glb/textured_mesh.glb',
            function (gltf) {
                const model = gltf.scene;
                scene.add(model);
                loadingElement.textContent = 'Model loaded!';
                
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);
                model.scale.setScalar(2);
                
                // Ensure materials are properly lit
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                        
                        if (child.material) {
                            child.material.needsUpdate = true;
                        }
                    }
                });
                
                controls.target.copy(center);
                controls.update();
                
                console.log('GLB model loaded:', gltf);
            },
            function (progress) {
                const percent = Math.round((progress.loaded / progress.total) * 100);
                loadingElement.textContent = `Loading model... ${percent}%`;
            },
            function (error) {
                console.error('Error loading GLB model:', error);
                loadingElement.textContent = 'Error loading model';
            }
        );

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Animate clouds
            animateClouds();
            
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>

</body>
</html>